Debugging en el navegador

El â€œdebuggingâ€ â€“ una herramienta especial de UI para desarrolladores que nos permite encontrar y reparar errores mÃ¡s fÃ¡cilmente.

El comando â€œdebuggerâ€
TambiÃ©n podemos pausar el cÃ³digo utilizando el comando debugger, asÃ­:

function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}

Este comando solo funciona cuando el panel de herramientas de desarrollo estÃ¡ abierto, de otro modo el navegador lo ignora.

En nuestro ejemplo, hello() se llama durante la carga de la pÃ¡gina, entonces la forma mas fÃ¡cil de activar el debugger es recargando la pÃ¡gina. Entonces presionemos F5 (en Windows Ã³ Linux) Ã³ Cmd+R (en Mac).

Como el breakpoint estÃ¡ definido, la ejecuciÃ³n se detiene en la lÃ­nea 4 y nos permite ver los detalles de la ejuciÃ³n.

-------------------------------------------------------------------------------------------------------------------------------------

Estilo de codificaciÃ³n
Nuestro cÃ³digo debe ser lo mÃ¡s limpio y fÃ¡cil de leer como sea posible.

Ese es en realidad el arte de la programaciÃ³n: tomar una tarea compleja y codificarla de manera correcta y legible para los humanos. Un buen estilo de cÃ³digo ayuda mucho en eso.

[Consultar la imÃ¡gen: 'codigoLimpio.png' para entender mejor la estructura y sintaxis].


- Llaves
En la mayorÃ­a de proyectos de Javascript las llaves estÃ¡n escritas en estilo â€œEgipcioâ€ con la llave de apertura en la misma linea como la correspondiente palabra clave â€“ no en una nueva linea. Debe haber tambiÃ©n un espacio antes de la llave de apertura, como esto:

if (condition) {
  // hacer esto
  // ...y eso
  // ...y eso
}

Una construcciÃ³n de una sola lÃ­nea, como if (condition) doSomething(), es un caso lÃ­mite importante. Â¿DeberÃ­amos usar llaves?

AquÃ­ estÃ¡n las variantes anotadas para que puedas juzgar la legibilidad por ti mismo.

ğŸ˜  Los principiantes a veces hacen eso. Â¡Malo! Las llaves no son necesarias:
if (n < 0) {alert(`Power ${n} is not supported`);}

ğŸ˜  Dividir en una lÃ­nea separada sin llaves. Nunca haga eso, es fÃ¡cil cometer un error al agregar nuevas lÃ­neas:
if (n < 0)
  alert(`Power ${n} is not supported`);

ğŸ˜ Una lÃ­nea sin llaves: aceptable, si es corta:
if (n < 0) alert(`Power ${n} is not supported`);

ğŸ˜ƒ La mejor variante:
if (n < 0) {
  alert(`Power ${n} is not supported`);
}

Recuerda: Para un cÃ³digo muy breve, se permite una lÃ­nea, p. if (cond) return null. Pero un bloque de cÃ³digo (la Ãºltima variante) suele ser mÃ¡s legible.

-------------------------------------------------------------------------------------------------------------------------------------

TamaÃ±o de lÃ­nea
A nadie le gusta leer una larga lÃ­nea horizontal de cÃ³digo. Es una buena prÃ¡ctica dividirlos.

Por ejemplo:

// acento grave ` permite dividir la cadena de caracteres en mÃºltiples lÃ­neas
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;

Y para sentencias if:

if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}

La longitud mÃ¡xima de la lÃ­nea debe acordarse con el equipo de trabajo. Suele tener 80 o 120 caracteres.

-------------------------------------------------------------------------------------------------------------------------------------

IndentaciÃ³n (sangrÃ­a)
Hay dos tipos de indentaciÃ³n:

IndentaciÃ³n horizontal: 2 o 4 espacios.

Se realiza una sangrÃ­a horizontal utilizando 2 o 4 espacios o el sÃ­mbolo de tabulaciÃ³n horizontal (key Tabulador). CuÃ¡l elegir es una vieja guerra santa. Los espacios son mÃ¡s comunes hoy en dÃ­a.

Una ventaja de los espacios sobre las tabulaciones es que los espacios permiten configuraciones de sangrÃ­a mÃ¡s flexibles que el sÃ­mbolo del tabulador.

Por ejemplo, podemos alinear los argumentos con el parÃ©ntesis de apertura, asÃ­:

show(parameters,
     aligned, // 5 espacios de relleno a la izquierda
     one,
     after,
     another
  ) {
  // ...
}

IndentaciÃ³n vertical: lÃ­neas vacÃ­as para dividir cÃ³digo en bloques lÃ³gicos.

Incluso una sola funciÃ³n a menudo se puede dividir en bloques lÃ³gicos. En el siguiente ejemplo, la inicializaciÃ³n de variables, el bucle principal y la devoluciÃ³n del resultado se dividen verticalmente:

function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}

Insertar una nueva lÃ­nea extra donde ayude a hacer el cÃ³digo mas legible. No debe haber mÃ¡s de nueve lÃ­neas de cÃ³digo sin una indentaciÃ³n vertical.

-------------------------------------------------------------------------------------------------------------------------------------

Punto y coma
Debe haber un punto y coma despuÃ©s de cada declaraciÃ³n, incluso si se puede omitir.

Hay idiomas en los que un punto y coma es realmente opcional y rara vez se usa. Sin embargo, en JavaScript, hay casos en los que un salto de lÃ­nea no se interpreta como un punto y coma, lo que deja el cÃ³digo vulnerable a errores.

Si eres un programador de JavaScript experimentado, puedes elegir un estilo de cÃ³digo sin punto y coma como StandardJS. De lo contrario, es mejor usar punto y coma para evitar posibles escollos. La mayorÃ­a de los desarrolladores ponen punto y coma.

-------------------------------------------------------------------------------------------------------------------------------------

Niveles anidados
Intenta evitar anidar el cÃ³digo en demasiados niveles de profundidad.

Algunas veces es buena idea usar la directiva â€œcontinueâ€ en un bucle para evitar anidamiento extra.

Por ejemplo, en lugar de aÃ±adir un if anidado como este:

for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- un nivel mÃ¡s de anidamiento
  }
}

Podemos escribir:

for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- sin nivel extra de anidamiento
}

Algo similar se puede hacer con if/else y return.

Por ejemplo, las dos construcciones siguientes son idÃ©nticas.

OpciÃ³n 1:

function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}

OpciÃ³n 2:

function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

El segundo es mÃ¡s legible porque el â€œcaso especialâ€ de n < 0 se maneja desde el principio. Una vez que se realiza la verificaciÃ³n, podemos pasar al flujo de cÃ³digo â€œprincipalâ€ sin la necesidad de anidamiento adicional.

-------------------------------------------------------------------------------------------------------------------------------------

Polyfills y transpiladores

Transpiladores:
Un transpilador es un software que traduce un cÃ³digo fuente a otro cÃ³digo fuente. Puede analizar (â€œleer y entenderâ€) cÃ³digo moderno y rescribirlo usando sintaxis y construcciones mÃ¡s viejas para que tambiÃ©n funcione en intÃ©rpretes antiguos.

Por ejemplo, antes del aÃ±o 2020 JavaScript no tenÃ­a el operador â€œnullish coalescingâ€ ??. Entonces, si un visitante lo usa en un navegador desactualizado, este fallarÃ­a en entender un cÃ³digo como height = height ?? 100.

Un transpilador analizarÃ­a nuestro cÃ³digo y rescribirÃ­a height ?? 100 como (height !== undefined && height !== null) ? height : 100.

// antes de ejecutar el transpilador
height = height ?? 100;

// despuÃ©s de ejecutar el transpilador
height = (height !== undefined && height !== null) ? height : 100;

Ahora el cÃ³digo rescrito es apto para los intÃ©rpretes de JavaScript mÃ¡s viejos.

Polyfills:
Nuevas caracterÃ­sticas en el lenguaje pueden incluir no solo construcciones sintÃ¡cticas y operadores, sino tambiÃ©n funciones integradas.

Por ejemplo, Math.trunc(n) es una funciÃ³n que corta la parte decimal de un nÃºmero, ej. Math.trunc(1.23) devuelve 1.

En algunos (muy desactualizados) intÃ©rpretes JavaScript no existe Math.trunc, asÃ­ que tal cÃ³digo fallarÃ¡.

AquÃ­ estamos hablando de nuevas funciones, no de cambios de sintaxis. No hay necesidad de transpilar nada. Solo necesitamos declarar la funciÃ³n faltante.

Un script que actualiza o agrega funciones nuevas es llamado â€œpolyfillâ€. Este llena los vacÃ­os agregando las implementaciones que faltan.

En este caso particular, el polyfill para Math.trunc es un script que lo implementa:

if (!Math.trunc) { // no existe tal funciÃ³n
  // implementarla
  Math.trunc = function(number) {
    // Math.ceil y Math.floor existen incluso en los intÃ©rpretes antiguos
    // los cubriremos luego en el tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}

-------------------------------------------------------------------------------------------------------------------------------------